# Jornada-de-Estudos
Relato do meu progresso

```json
{
"firstName": "Renato",
"lastName": "Lima",
"age": 29
}
```

**Dia 1<br>17 de Abril de 2022 - Domingo**<br>*70 minutos de estudo*
* **Plataforma GitHub** <br> *Ideias importantes* <br> repositório // branch // commit // markdown // pull request.

---
**Dia 2<br>18 de Abril de 2022 - Segunda**<br>*250 minutos de estudo*
* **Curso CS50x 2022**<br>*Ideias importantes*<br>switches or transistors or bit // 01000001 = "A" or 65 (formatos diferentes de compactação de dados) // ASCII - American Standard Code for Information Interchange // bytes = 8 bits // Unicode // lossy (perde qualidade) and lossless (eficiência no uso de dados) // functions (arguments or statements; return values) // conditions // boolean expressions // loops // events // input (argument or parameter) // abstractions // script = program, sprite, variables.
> *Project 0 - Scratch.*
> <p> Desenvolvi um jogo usando a palataforma: https://scratch.mit.edu/ <br>Sites usados como auxílio: https://opengameart.org/ ; https://www.kenney.nl/assets ;</p> 

---
**Dia 3<br>19 de Abril de 2022 - Terça**<br>*350 minutos de estudo*
> *Project 0 - Bald Naked Shield Hero*
> <p> Sites usados como auxílio: https://www.dafont.com/ </p>

---
**Dia 4<br>20 de Abril de 2022 - Quarta**<br>*300 minutos de estudo*
> *Project 0 - Bald Naked Shield Hero*
> <p> Sites usados: https://lingojam.com/ScaryVoiceChanger <br> Projeto finalizado.<br> https://scratch.mit.edu/projects/677657468/ </p>
* **[CS50x] Week 1 - C**<br>Ideias importantes<br>corret & design (eficiente e fácil de leitura) & style, machine code //  source code (linguagem humana -> linguagem computacional) // compiler // command line interface (CLI) or terminal // "." - acessar a pasta atual // "/" - rodar o programa que existe com o nome a seguir // Graphical User Interface (GUI) // "rm" - remover algo // "ls" - lista todos os arquivos que estão na pasta que está sendo acessada // assignment operator (=) // %s ",'variable'" // header file // cp - copiar // mkdir - fazer um diretório // mv - mover ou renomear arquivo // rmdir - remover de um diretório // cd - mudar para outro diretório // ctr+l (hotkey to clean) // code - cria um arquivo para codificar // "cd .." - retorna para a pasta anterior // Integrated Development Environment (IDE == VCS).

---
**Dia 5<br>21 de Abril de 2022 - Quinta**<br>*325 minutos de estudo*
> *Project 1-1 - MarioH* 
<img src="https://user-images.githubusercontent.com/103901889/165348916-4d2e7576-019a-4672-b759-01a8ce973f4e.png" width="550" height="100">

> *Project 1-2 - Credit* 

*Comecei a consumir assuntos relacionados a programação. Hipster podcast - Ponto positivo: Diversidade de assuntos. Ponto negativo: Foca excessivamente no merchandising da Alura.*

---
**Dia 6<br>22 de Abril de 2022 - Sexta**<br>*300 minutos de estudo*
> *Project 1-2 - Credit* <p> </p>
<img src="https://user-images.githubusercontent.com/103901889/165348810-2ea860a5-bef2-41c1-97cf-9843ec1279c6.png" width="550" height="100">

> *Project 1-3 - Cash* 
<img src="https://user-images.githubusercontent.com/103901889/165348882-ae70cf33-33b3-4812-85ce-e58e7eb606ab.png" width="550" height="100">

*Podcast: Data Hackers. Ponto negativo: Focado na área de big data.*

---
**Dia 7<br>23 de Abril de 2022 - Sábado**<br>*200 minutos de estudo*
* **[CS50x] Week 2 - Arrays**<br>*Ideias importantes*<br>I - preprocessing (colocar outros programas que possuem funções com um # inicialmente garante ao código que as funções que estão inclusas lá serão usadas em algum momento), II - compiling (assembly language - uma linguagem bastante primitiva. As outras linguagens, quando são compiladas, elas são traduzidas, inicialmente, para esta linguagem antes de se tornar uma linguagem binária), III - assembling (é nesse processo que a tradução para o número binário acontece), IV - linking, preprocessor directives, "a.out" (assembler out - nome padrão dado quando usado a compilação pelo comando clang) // três formas de encontrar bugs no código (a - usando printf; b - usando debugger (a.k.a debug50 ./"arquivo compilado"); c - rubber duck - explicar o código para um pato imaginário) // string = são arrays de char // null = \0.

*Youtube: Fabio Akita. Sensacional. Irei começar a escutar esse diariamente.*

---
**Dia 8<br>24 de Abril de 2022 - Domingo**<br>*80 minutos de estudo*
* **[CS50x] Week 2 - Arrays**<br>*Ideias importantes*<br>argc (argument count) // argv (argument vector or argument list) // return 0 (always false) // return =! 0 (qualquer número, é considerado verdadeiro) // plaintext // cipher // ciphertext // functions == procedures == methods == black box (Organization; Simplification; Reusability) // /return-type name(argument-list);\ // double é duas vezes mais preciso que o float (7 casas decimais) //  function definition != function declaration. 

*Audiobook: The Pragmatic Programmer. Conforme sugerido pelo podcast Hipster.*

---
**Dia 9<br>25 de Abril de 2022 - Segunda**<br>*325 minutos de estudo*
* **[CS50x] Week 2 - Arrays**<br>*Ideias importantes*<br>local variable // global variable // array-elements-data(int and char)-index // passing by value (a função é realizada através de uma cópia de uma variável) // passing by reference (particularidade da array. É usado a variável em si na função).
> *Project 2-0 - Scrabble* - Lembrar: type array[] = {}; != type array[MAX]; 
<img src="https://user-images.githubusercontent.com/103901889/165348670-fc818816-a15d-4fb4-a3c9-0f52554384ce.png" width="550" height="100">

> *Project 2-1 - Readability*
<img src="https://user-images.githubusercontent.com/103901889/165348617-3eee7dd2-92ca-4486-befe-d8cf7e32276d.png" width="550" height="100">

> *Project 2-2 - Substitution*

---
**Dia 10<br>26 de Abril de 2022 - Terça**<br>*330 minutos de estudo*
> *Project 2-2 - Substituion*
<img src="https://user-images.githubusercontent.com/103901889/165347669-738d87df-f349-4946-b227-fa1f8fb0a1f5.png" width="550" height="100">

> *Project 2-3 - Caesar*
<img src="https://user-images.githubusercontent.com/103901889/165389938-b43e8b32-fe4c-4cf0-8327-3519b5edd5a8.png" width="550" height="100">

* **[CS50x] Week 3 - Algorithms**<br>*Ideias importantes*<br>RAM (Random Access Memory) // big O notation "big O of log n" // FOR conditional (o tempo que o algorítimo leva para ser realizado) // / O(n^2); O(n log n); O(n); O(log n); O(1); \ // 'símbolo OMEGA' (lower bound) -> "Menor tentativa possível" // O (upper bound) -> "Máximo de tentativa possível" // 'símbolo THETA' quando o lower bound == upper bound // linear search // O(log n) // Binary search -> Lembrar: rasgar a lista telefônica no meio, string não é um tipo de data per si (junção de char).

---
**Dia 11<br>27 de Abril de 2022 - Quarta**<br>*330 minutos de estudo*
* **[CS50x] Week 3 - Algorithms**<br>*Ideias importantes*<br>data structure - "typedef struct"{} / nameDataType; (criação do tipo de data que será usado na linguagem) // data structure do C é diferente dos 'objetos' de outras linguagems (os objetos, além de armazenarem dados, são capazes de armazenar funções. C não possui orientação de objetos) // selection sort (procura o elemento que temos interesse) // n(n+1)/2 ~~ [Simplification]-> O(n^2) // bubble sort = O(n^2) - o Omega é menor que o slection sort - (n-1 times) // recursion (função se auto chamar) // merge sort O (n log n).

> *Project 3-1 - Tideman*

---
**Dia 12<br>28 de Abril de 2022 - Quinta**<br>*350 minutos de estudo*
> *Project 3-1 - Tideman*

---
**Dia 13<br>29 de Abril de 2022 - Sexta**<br>*325 minutos de estudo*
> *Project 3-1 - Tideman*

---
**Dia 14<br>30 de Abril de 2022 - Sábado**<br>*400 minutos de estudo*
> *Project 3-1 - TideMan*

---
**Dia 15<br> 01de Maio de 2022 - Domingo**<br>*100 minutos de estudo*
> *Project 3-1 - Tideman*

---
**Dia 16<br>02 de Maio de 2022 - Segunda**<br>*475 minutos de estudo*
> *Project 3-1 - Tideman*
<img src="https://user-images.githubusercontent.com/103901889/166341325-fdec20cc-14f7-43a0-8c38-fd00fc588ce4.png" width="550" height="100">

> *Project 3-2 - Runoff*
<img src="https://user-images.githubusercontent.com/103901889/166341526-3004088a-b191-4838-ba67-11789e51c164.png" width="550" height="100">

---
**Dia 17<br>03 de Maio de 2022 - Terça**<br>*350 minutos de estudo*
* **[CS50x] Week 4 - Memory**<br>*Ideias importantes*<br>rows = scan lines // 8 bits - O máximo valor numérico é 255 // hexadecimal - Bastante usado para representar cores & memória (0x -> prefixo que é colocado para identificar que o computador está usando uma notação hexadecimal para aquele valor numérico) // Na contagem hexadecimal, usamos 2 unidades para representar um total de 255, portanto, cada unidade dessa tem a mesma proporação que 4 unidades na notação binária. F | F (240 + 15) -> 1111 | 1111 (128 + 64 + 32 + 16 + 8 + 4 + 2 + 1) // pointers -> é uma variável que identifica onde está localizado a variável apontada na memória. Sendo mais específico, irá informar qual é o byte especifico que está armazenando aquela informação -> int n = 5; int \*p = &n; \*-> Significa que eu não quero acessar o data type da variável n, mas sim o seu endereço. // %p -> printf para printar pointers // erros relacionados ao uso da memória -> stack overflow & heap overflow & buffer overflow // int * -> esse é um tipo de dado chamado pointers. int != int * // Se eu criar uma variável pointers, eu posso fazer o trajeto contrário. Em vez dele representar apenas o lugar que está armazenado na memória, eu posso perguntar qual é o valor da variável que está armazenado na memória que ele está representando. Para isso, eu uso o ("%i", \*p). // char * -> Canso a expressão for um string, irá procurar a primeira letra e irá até o null // strings são armazenados no começo da memória enquanto int e floats são armazenados mais no final da memória // pointer arithmetic -> \*s, \*(s + 1), \*(s + 2) -> Acessa outros espaços dos caracter de uma string e gera no valor deles. É a mesma coisa que s[0], s[1]... // Há uma semelhança no uso da busca de endereço e array, já que ambos buscam identificar o valor que queremos obter na localização desejada // string (pointers) -> fornece o endereço do primeiro caracter da string. // Quando se cria uma variável para copiar uma variável string, ambas representam o mesmo endereço. Isso impacta na manipulação das variáveis // dynamic memory allocation - malloc (liberar memória para uso do programador) & free (devolver a memória para o sistema) // NULL -> É usado para identificar se um pointer é válido ou não. Se o malloc não funcionar, isto é, ele não conseguir liberar espaço na memória, é fundamental que ele traga como resultado o NULL // Se eu for fazer um for loop para copiar uma string, lembrar: (strlen(x) + 1), já que eu preciso também copiar o \\0 // Buffer overflow -> acessando memória não fornecida pelo malloc. // valgrind ./name_file (é um programa usado para identificar bugs relacionados à memória) // memory leak -> Ter solicitado memória sem ter devolvido a mesma para o sistema posteriormente // garbage value -> valores que são preenchidos automaticamente pelo computador quando criado array sem valor. Esses valores gerados automaticamente podem ter importância, já que o sistema pode preencher o espaço em branco com senhas ou cartão de crédito. // As informações são armazenadas de uma forma organizada: machine code > globals > heap (variáveis acrescentadas junto com malloc) > stack (variáveis locais). // stack overflow -> Por conta de um aumento significativo do uso do malloc e/ou uso de variáveis locais, o uso da memória é ultrapassado de um limite funcional. // dereferencing -> sinalizando o endereço na memória de alguma variável // FILE -> É um pointer para sinalizar a busca de um arquivo no sistema. // A - append (acrescentar nova informação no final do arquivo) R - read W - write (sobrescrever com a nova informação a velha informação que está presente no arquivo) // Só é possível alterar variáveis locais com o uso dos pointers, pois, caso não tiver passado a localização de uma variável local, é criado uma cópia da mesma para ser usada na função // HDD - Hard Disk Drive // SSD - Solid-state drive // HDD e SSD são os locais de armazenado de dados, já o RAM é a manipulação desses dados // 1 bit - Valor binário / 1 Byte - 8 bits // Big Endian -> A notação do valor binário num byte é contado da esquerda para a direita. // Little Endian -> O contrário do Big ENdian.

---
**Dia 18<br>04 de Maio de 2022 - Quarta**<br>*350 minutos de estudo*
* **[CS50x] Week 4 - Memory**<br>*Ideias importantes*<br>LSB representa a parte menos significativa do número (parte mais a direita) MSB representa a parte mais significativa (parte mais a esquerda) // dereferencing -> a partir do endereço da memória de alguma variável, ser capaz de fazer alteração nela // * -> dereference operator // 3 regras gerais para alocação dinâmica de memória. 1º - Todo o bloco de memória fornecido pelo malloc() deve ser devolvido par o sistema no final pelo free(); 2º - Apenas as memórias geradas pelo malloc() devem ser devolvidas; 3º - Nunca chamar a função free() duas vezes para o mesmo bloco de memória. // os pointers possuem duas informações intrísecas: o seu valor sinaliza o endereço de uma memória e o seu tipo descreve o tipo da unidade que está armazenada. // typedef long byte; (pode alterar o nome de uma estrutura já existente) // Call Stack - A ordenação da execução das funções que foram solicitadas para o sistema. Cada código chamado na expressão é conhecido como stack frames ou function frames, nos quais são ordenados num stack, que gerencia a ordem de execução de cada função. Algumas funções ficam pausadas de execução, enquanto a função chamada mais recentemente possui prioridade. Quando esta é chamada pelo sistema, denominamos como pushed. Quando esta termina a sua função no sistema, denominamos popped. // EOF - End Of File

> *Project 4-1 - Filters*

Sites usados como auxílio: https://docs.fileformat.com/

---
**Dia 19<br>05 de Mario de 2022**<br>*50 minutos de estudo*

> *Project 4-1 - Filters
